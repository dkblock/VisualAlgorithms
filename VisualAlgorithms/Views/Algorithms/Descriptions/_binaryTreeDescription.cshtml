@model VisualAlgorithms.Models.Algorithm

<div>
    <h3 class="description-section-title">@Model.Name</h3>
    <hr/>
    <div class="description-container">
        <div class="col-8">
            <p class="description-paragraph">
                <b>Бинарное дерево поиска</b> — это двоичное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):

                <ul>
                    <li>Каждый узел имеет не более двух потомков.</li>
                    <li>У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X.</li>
                    <li>У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, чем значение ключа данных самого узла X.</li>
                </ul>
            </p>
            <p class="description-paragraph">
                Основным преимуществом бинарного дерева поиска перед другими структурами данных является возможная высокая эффективность реализации основанных на нём алгоритмов поиска и сортировки.
            </p>
        </div>
        <div class="col-4">
            <img class="description-image" src="@Model.ImageUrl" />
        </div>
    </div>
</div>
<div>
    <h3 class="description-section-title">Определения</h3>
    <hr />
    <div class="description-container">
        <div class="col-8">
            <p class="description-paragraph">
                <b>Корневой узел</b> — это узел, находящийся на самом верхнем уровне и не являющийся чьим-либо потомком (узел 8).<br />
                <b>Лист</b> — это узел, не имеющий дочерних элементов (узлы 1, 4, 10, 13).<br />
                <b>Внутренний узел</b> — это любой узел дерева, имеющий потомков, то есть, не являющийся листовым узлом (узлы 3, 5, 9, 12).<br />
                <b>Высота узла</b> — это длина наибольшего пути от него до дочернего узла, являющегося листом.<br />
                <b>Высота дерева</b> — это длина наибольшего пути от корня к листу (высота дерева на примере равна 3).<br />
            </p>
        </div>
        <div class="col-4">
            <img class="description-image" src="images/descriptions/@Model.Tag/example.png" />
            <h6 class="text-center">Простой пример бинарного дерева</h6>
        </div>
    </div>
</div>
<div>
    <h3 class="description-section-title">Основные операции</h3>
    <hr />
    <div class="description-container">
        <div class="col-8">
            <p class="description-paragraph">
                Основными операциями в бинарном дереве поиска являются:
                <ul>
                    <li><i>INSERT(K, V)</i> — добавление в дерево пары (key, value) = (K, V).</li>
                    <li><i>FIND(K)</i> — поиск узла, в котором хранится пара (key, value) с key = K.</li>
                    <li><i>REMOVE(K)</i> — удаление узла, в котором хранится пара (key, value) с key = K.</li>
                </ul>
            </p>
            <p class="description-paragraph">
                <h5>Вставка элемента (INSERT)</h5>
                <b>Задача:</b> вставить пару (K, V) в дерево Т (при совпадении K, заменить V).<br />
                <b>Алгоритм:</b>
                <ul>
                    <li>Если дерево пусто, заменить его на дерево с одним корневым узлом (K, V) и остановиться.</li>
                    <li>
                        Иначе сравнить K со значением ключа корневого узла X.
                        <ul>
                            <li>
                                Если K>X, рекурсивно добавить (K, V) в правое поддерево Т.
                            </li>
                            <li>
                                Если K&lt;X, рекурсивно добавить (K, V) в левое поддерево Т.
                            </li>
                            <li>
                                Если K=X, заменить V текущего узла новым значением.
                            </li>
                        </ul>
                    </li>
                </ul>
                <div class="description-image-container">
                    <img class="description-image" src="images/descriptions/@Model.Tag/insert.gif" />
                    <h6 class="text-center">Вставка узла 42</h6>
                </div>
            </p>
            <p class="description-paragraph">
                <h5>Поиск элемента (FIND)</h5>
                <b>Задача:</b> проверить, есть ли узел с ключом K в дереве Т, и если да, то вернуть ссылку на этот узел.<br />
                <b>Алгоритм:</b>
                <ul>
                    <li>Если дерево пусто, сообщить, что узел не найден, и остановиться.</li>
                    <li>
                        Иначе сравнить K со значением ключа корневого узла X.
                        <ul>
                            <li>
                                Если K=X, выдать ссылку на этот узел и остановиться.
                            </li>
                            <li>
                                Если K>X, рекурсивно искать ключ K в правом поддереве Т.
                            </li>
                            <li>
                                Если K&lt;X, рекурсивно искать ключ K в левом поддереве Т.
                            </li>
                        </ul>
                    </li>
                </ul>
                <div class="description-image-container">
                    <img class="description-image" src="images/descriptions/@Model.Tag/find.gif" />
                    <h6 class="text-center">Поиск узла 14</h6>
                </div>
            </p>
            <p class="description-paragraph">
                <h5>Удаление элемента (REMOVE)</h5>
                <b>Задача:</b> удалить из дерева Т узел с ключом K (если такой есть).<br />
                <b>Алгоритм:</b>
                <ul>
                    <li>Если дерево T пусто, остановиться;</li>
                    <li>
                        Иначе сравнить K со значением ключа корневого узла Х.
                        <ul>
                            <li>
                                Если K>X, рекурсивно удалить K из правого поддерева Т;
                            </li>
                            <li>
                                Если K&lt;X, рекурсивно удалить K из левого поддерева Т;
                            </li>
                            <li>
                                Если K=X, то необходимо рассмотреть три случая:
                                <ul>
                                    <li>
                                        Если обоих детей нет, то удаляем текущий узел и обнуляем ссылку на него у родительского узла;
                                    </li>
                                    <li>
                                        Если одного из детей нет, то значения полей ребёнка m ставим вместо соответствующих значений корневого узла;
                                    </li>
                                    <li>
                                        Если оба ребёнка присутствуют, то:
                                        <ul>
                                            <li>
                                                Если левый узел m правого поддерева отсутствует, то копируем из правого узла в удаляемый поля K, V и ссылку на правый узел правого потомка.
                                            </li>
                                            <li>
                                                Иначе
                                                <ul>
                                                    <li>
                                                        Возьмём самый левый узел m правого поддерева;
                                                    </li>
                                                    <li>
                                                        Скопируем данные (кроме ссылок на дочерние элементы) из m в X;
                                                    </li>
                                                    <li>
                                                        Рекурсивно удалим узел m.
                                                    </li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                <div class="description-image-container">
                    <img class="description-image" src="images/descriptions/@Model.Tag/remove.gif" />
                    <h6 class="text-center">Удаление узла 18</h6>
                </div>
            </p>
        </div>
        <div class="col-4">
            @{ await Html.RenderPartialAsync("_AlgorithmTimeComplexity", Model.AlgorithmTimeComplexity);}
        </div>
    </div>
    <div>
        <h3 class="description-section-title">Сбалансированные и несбалансированные деревья</h3>
        <hr />
        <div class="description-container">
            <div class="col-8">
                <p class="description-paragraph">
                    <b>Сбалансированное дерево</b> — это такое дерево, для каждого узла которого количество узлов в его левом и правом поддеревьях
                    различается не более, чем на 1 (рис. 1).
                </p>
                <p class="description-paragraph">
                    Само по себе бинарное дерево поиска не является сбалансированным деревом, и в худшем случае вырождается в список (рис. 2).
                    При этом теряется производительность, поэтому для наилучшего быстродействия желательно,чтобы глубина и левого, и правого поддеревьев
                    в каждом узле была примерно одинакова. Из-за этого ограничения на практике чаще всего используются сбалансированные деревья.
                </p>
                <p class="description-paragraph">
                    Однако обычные бинарные деревья также могут оказаться полезны. Как показывает практика, они ничем не уступают сбалансированным
                    деревьям при работе со случайным неупорядоченным набором данных. В совокупности с их довольно простой реализацией, это позволяет
                    сделать выбор в пользу обычных бинарных деревьев (именно на наборе случайных данных).
                </p>
            </div>
            <div class="col-4">
                <div class="description-image-container">
                    <img class="description-image" src="images/descriptions/@Model.Tag/balanced.png" />
                    <h6 class="text-center">Сбалансированное дерево</h6>
                </div>
                <div class="description-image-container">
                    <img class="description-image" src="images/descriptions/@Model.Tag/unbalanced.png" />
                    <h6 class="text-center">Несбалансированное дерево</h6>
                </div>
            </div>
        </div>
    </div>
</div>