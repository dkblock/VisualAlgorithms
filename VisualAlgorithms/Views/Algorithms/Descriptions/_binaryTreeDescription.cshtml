@model VisualAlgorithms.Models.Algorithm

<div>
    <h3 class="description-section-title">Определение</h3>
    <hr/>
    <div class="description-container">
        <div class="col-8">
            <p class="description-paragraph">
                <b>Бинарное дерево поиска</b> — это двоичное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):

                <ul>
                    <li>Каждый узел имеет не более двух потомков.</li>
                    <li>У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, чем значение ключа данных самого узла X.</li>
                    <li>У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, чем значение ключа данных самого узла X.</li>
                </ul>
            </p>
            <p class="description-paragraph">
                Основным преимуществом бинарного дерева поиска перед другими структурами данных является возможная высокая эффективность реализации основанных на нём алгоритмов поиска и сортировки.
            </p>
        </div>
        <div class="col-4">
            <img class="description-image" src="images/@Model.ImageUrl"/>
        </div>
    </div>
</div>
<div>
    <h3 class="description-section-title">Основные операции</h3>
    <hr/>
    <div class="description-container">
        <div class="col-8">
            <p class="description-paragraph">
                Основными операциями в бинарном дереве поиска являются:
                <ul>
                    <li><i>FIND(K)</i> — поиск узла, в котором хранится пара (key, value) с key = K.</li>
                    <li><i>INSERT(K, V)</i> — добавление в дерево пары (key, value) = (K, V).</li>
                    <li><i>REMOVE(K)</i> — удаление узла, в котором хранится пара (key, value) с key = K.</li>
                </ul>
            </p>
            <p class="description-paragraph">
                <h5>Поиск элемента (FIND)</h5>
                <b>Задача:</b> проверить, есть ли узел с ключом K в дереве Т, и если да, то вернуть ссылку на этот узел.<br />
                <b>Алгоритм:</b>
                <ul>
                    <li>Если дерево пусто, сообщить, что узел не найден, и остановиться.</li>
                    <li>
                        Иначе сравнить K со значением ключа корневого узла X.
                        <ul>
                            <li>
                                Если K=X, выдать ссылку на этот узел и остановиться.
                            </li>
                            <li>
                                Если K>X, рекурсивно искать ключ K в правом поддереве Т.
                            </li>
                            <li>
                                Если K&lt;X, рекурсивно искать ключ K в левом поддереве Т.
                            </li>
                        </ul>
                    </li>
                </ul>
            </p>
            <p class="description-paragraph">
                <h5>Вставка элемента (INSERT)</h5>
                <b>Задача:</b> вставить пару (K, V) в дерево Т (при совпадении K, заменить V).<br />
                <b>Алгоритм:</b>
                <ul>
                    <li>Если дерево пусто, заменить его на дерево с одним корневым узлом (K, V) и остановиться.</li>
                    <li>
                        Иначе сравнить K со значением ключа корневого узла X.
                        <ul>
                            <li>
                                Если K>X, рекурсивно добавить (K, V) в правое поддерево Т.
                            </li>
                            <li>
                                Если K&lt;X, рекурсивно добавить (K, V) в левое поддерево Т.
                            </li>
                            <li>
                                Если K=X, заменить V текущего узла новым значением.
                            </li>
                        </ul>
                    </li>
                </ul>
            </p>
            <p class="description-paragraph">
                <h5>Удаление элемента (REMOVE)</h5>
                <b>Задача:</b> удалить из дерева Т узел с ключом K (если такой есть).<br />
                <b>Алгоритм:</b>
                <ul>
                    <li>Если дерево T пусто, остановиться;</li>
                    <li>
                        Иначе сравнить K со значением ключа корневого узла Х.
                        <ul>
                            <li>
                                Если K>X, рекурсивно удалить K из правого поддерева Т;
                            </li>
                            <li>
                                Если K&lt;X, рекурсивно удалить K из левого поддерева Т;
                            </li>
                            <li>
                                Если K=X, то необходимо рассмотреть три случая:
                                <ul>
                                    <li>
                                        Если обоих детей нет, то удаляем текущий узел и обнуляем ссылку на него у родительского узла;
                                    </li>
                                    <li>
                                        Если одного из детей нет, то значения полей ребёнка m ставим вместо соответствующих значений корневого узла;
                                    </li>
                                    <li>
                                        Если оба ребёнка присутствуют, то:
                                        <ul>
                                            <li>
                                                Если левый узел m правого поддерева отсутствует, то копируем из правого узла в удаляемый поля K, V и ссылку на правый узел правого потомка.
                                            </li>
                                            <li>
                                                Иначе
                                                <ul>
                                                    <li>
                                                        Возьмём самый левый узел m правого поддерева;
                                                    </li>
                                                    <li>
                                                        Скопируем данные (кроме ссылок на дочерние элементы) из m в X;
                                                    </li>
                                                    <li>
                                                        Рекурсивно удалим узел m.
                                                    </li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </p>
        </div>
        <div class="col-4">
            @{ await Html.RenderPartialAsync("_AlgorithmTimeComplexity", Model.AlgorithmTimeComplexity);}
        </div>
    </div>
</div>